services:
  # DCS (required by Patroni)
  etcd:
    image: gcr.io/etcd-development/etcd:v3.6.6
    command:
      - /usr/local/bin/etcd
      - --name=etcd1
      - --data-dir=/etcd-data
      - --listen-client-urls=http://0.0.0.0:2379
      - --advertise-client-urls=http://etcd:2379
      - --listen-peer-urls=http://0.0.0.0:2380
      - --initial-advertise-peer-urls=http://etcd:2380
      - --initial-cluster=etcd1=http://etcd:2380
      - --initial-cluster-state=new
    environment:
      - ETCDCTL_API=3
    ports:
      - "2379:2379"
    volumes:
      - etcd-data:/etcd-data
    healthcheck:
      test: ["CMD", "etcdctl", "endpoint", "health", "--endpoints=http://127.0.0.1:2379"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 5s

  # Postgres 18 + Patroni node 1
  pg1:
    build:
      context: ./patroni
    container_name: pg1
    depends_on:
      etcd:
        condition: service_healthy
    volumes:
      # Your requested volume structure (mount parent dir, PGDATA is /var/lib/postgresql/data)
      - pg1-data:/var/lib/postgresql
      # Your existing config file (used as Patroni custom_conf base)
      - ./postgresql.conf:/etc/postgresql/postgresql.conf:ro
      - ./patroni/pg1.yml:/config/patroni.yml:ro
    environment:
      - PGDATA=/var/lib/postgresql/data
    ports:
      - "5435:5432"   # optional direct access (debug)
      - "8008:8008"   # Patroni REST API (debug)
    restart: unless-stopped

  # Postgres 18 + Patroni node 2
  pg2:
    build:
      context: ./patroni
    container_name: pg2
    depends_on:
      etcd:
        condition: service_healthy
    volumes:
      - pg2-data:/var/lib/postgresql
      - ./postgresql.conf:/etc/postgresql/postgresql.conf:ro
      - ./patroni/pg2.yml:/config/patroni.yml:ro
    environment:
      - PGDATA=/var/lib/postgresql/data
    ports:
      - "5436:5432"   # optional direct access (debug)
      - "8009:8008"   # Patroni REST API (debug, mapped)
    restart: unless-stopped

  # Stable endpoint (KEEP THIS NAME `db` so your app/dbgate configs don't break)
  db:
    image: haproxy:2.9
    container_name: db
    depends_on:
      - pg1
      - pg2
    volumes:
      - ./haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro
    ports:
      - "5432:5432"   # read-write (primary)
      - "5433:5433"   # read-only (primary+replicas) optional
    restart: unless-stopped


  rabbit:
    image: rabbitmq:3.13-management
    ports: ["5672:5672", "15672:15672"]
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest

  kafka:
    image: apache/kafka:4.1.0
    ports: ["9092:9092"]
    environment:
      KAFKA_NODE_ID: 1
      KAFKA_PROCESS_ROLES: broker,controller
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
      KAFKA_CONTROLLER_QUORUM_VOTERS: 1@kafka:9093
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_AUTO_CREATE_TOPICS_ENABLE: "true"
      CLUSTER_ID: MkU3OEVBNTcwNTJENDM2Qk
    volumes:
      - kafka-data:/var/lib/kafka/data

  # api:
  #   build: ./api
  #   env_file: ./api/.env
  #   depends_on: [db, rabbit]
  #   ports: ["3001:3001"]

  # web:
  #   build: ./web
  #   env_file: ./web/.env.local
  #   depends_on: [api]
  #   ports: ["3000:3000"]


  dbgate:
    image: dbgate/dbgate
    depends_on: [db]
    ports: ["3003:3000"]
    environment:
      CONNECTIONS: local
      LABEL_local: Workflow PG
      SERVER_local: db
      USER_local: postgres
      PASSWORD_local: postgres
      ENGINE_local: postgres@dbgate-plugin-postgres
      DATABASE_local: workflow


volumes:
  etcd-data:
  pg1-data:
  pg2-data:
  pgadmin_data:
  kafka-data:



# docker compose down --volumes --remove-orphans
# docker compose up -d --build db rabbit
# # check: http://localhost:15672  (guest/guest)
# docker compose run --rm api sh -lc "npm ci && npm run db:init && npm run build && npm start"
# docker compose run --rm -p 3000:3000 web sh -lc "npm ci && npm run dev"

# docker compose run --rm api sh -lc "psql -h db -U postgres -d workflow -f ./schema.sql"
